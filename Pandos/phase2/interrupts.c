/**************************************************************************** 
  *
  * This module contains the definition for all interrupt-handling functions.
  * Such functions are called by the Nucleus in initial.c.
  * 
  * Written by: Kollen Gruizenga and Jake Heyser
  *
  ****************************************************************************/

 #include "../h/asl.h"
 #include "../h/types.h"
 #include "../h/const.h"
 #include "../h/pcb.h"
 #include "../h/scheduler.h"
 #include "../h/interrupts.h"
 #include "../phase2/initial.c"

 /* Function declarations */
 HIDDEN void pltTimerInt(pcb_PTR proc);
 HIDDEN void intTimerInt(pcb_PTR proc);
 HIDDEN void terminalInt(pcb_PTR proc);
 HIDDEN void IOInt(pcb_PTR proc);

 /* Declaring global variables */
 cpu_t curr_tod; /* the current value on the Time of Day clock */
 cpu_t remaining_time; /* the amount of time left on the Current Process' quantum */
 state_PTR savedExceptState; /* a pointer to the saved exception state */

 /* Internal helper function that handles Processor Local Timer (PLT) interrupts */
 void pltTimerInt(pcb_PTR proc){
 	if (proc != NULL){
 		moveState(savedExceptState, &(proc->p_s)); /* moving the updated saved exception state from the BIOS Data Page into the Current Process' processor state */
 		proc->p_time = proc->p_time + (curr_tod - start_tod); /* updating the accumulated processor time used by the Current Process */
 		insertProcQ(&ReadyQueue, proc); /* placing the Current Process back on the Ready Queue because it has not completed its CPU Burst */
 		switchProcess(); /* calling the Scheduler to begin execution of the next process on the Ready Queue */
 	}
 	else{
 		PANIC(); /* invoking the PANIC() function to stop the system and print a warning message on terminal 0 */
 	}
 }

 /* Internal helper function that handles interrupts generated by the System-wide Interval Timer */
 void intTimerInt(pcb_PTR proc){
 	LDIT(INITIALINTTIMER); /* placing 100 milliseconds back on the Interval Timer for the next Pseudo-clock tick */
 	/* unblocking all pcbs blocked on the Pseudo-Clock semaphore */
	while (headBlocked(&deviceSemaphores[PCLOCKIDX]) != NULL){ /* while the Pseudo-Clock semaphore has a blocked pcb */
		removeBlocked(&deviceSemaphores[PCLOCKIDX]); /* unblock the first (i.e., head) pcb from the Pseudo-Clock semaphore's process queue */
	}
	deviceSemaphores[PCLOCKIDX] = INITIALPCSEM; /* resetting the Pseudo-clock semaphore to zero */
	moveState(savedExceptState, &(proc->p_s)); /* moving the updated saved exception state from the BIOS Data Page into the Current Process' processor state */
	proc->p_time = proc->p_time + (curr_tod - start_tod); /* updating the accumulated processor time used by proc */
	if (currentProc != NULL){ /* if there is a Current Process to return control to */
		switchContext(proc); /* calling the function that returns control to the Current Process */
 	}
	switchProcess(); /* if there is no Current Process to return control to, call the Scheduler function to begin executing a new process */
}

 /* Nucleus' device interrupt handler function (exception code 0) */
 void intTrapH(){
 	/* initializing global variables */
 	STCK(curr_tod); /* initializing the current value on the Time of Day clock */
 	remaining_time = getTIMER(); /* initializing the remaining time left on the Current Process' quantum */
	savedExceptState = (state_PTR) BIOSDATAPAGE; /* initializing the saved exception state to the state stored at the start of the BIOS Data Page */

 	/* determining the line number that the interrupt occurred on so we can call the appropriate interrupt handler function */
 	if (savedExceptState->s_cause & LINE1INT != ALLOFF){ /* if there is an interrupt on line 1 */
 		pltTimerInt(currentProc);
 	}
 	if (savedExceptState->s_cause & LINE2INT != ALLOFF){ /* if there is an interrupt on line 2 */
 		intTimerInt(currentProc);
 	}
 	if (savedExceptState->s_cause & LINE7INT != ALLOFF){ /* if there is an interrupt on line 7 */
		terminalInt(currentProc);
 	}
 	IOInt(currentProc);
 }