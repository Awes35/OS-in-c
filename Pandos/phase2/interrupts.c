/**************************************************************************** 
  *
  * This module contains the definition for all interrupt-handling functions.
  * Such functions are called by the Nucleus in initial.c.
  * 
  * Written by: Kollen Gruizenga and Jake Heyser
  *
  ****************************************************************************/

 #include "../h/asl.h"
 #include "../h/types.h"
 #include "../h/const.h"
 #include "../h/pcb.h"
 #include "../h/scheduler.h"
 #include "../h/interrupts.h"
 #include "../phase2/initial.c"

 /* Function declarations */
 HIDDEN void findDeviceNum();
 HIDDEN void pltTimerInt();
 HIDDEN void intTimerInt();

 /* Declaring global variables */
 cpu_t curr_tod; /* the current value on the Time of Day clock */
 cpu_t remaining_time; /* the amount of time left on the Current Process' quantum */

 // /* Internal helper function for determining the device number associated with the highest-priority
 // interrupt. The function initializes the global variable deviceNum to that number */
 // void findDeviceNum(){
 // 	/* declaring local variables */
 // 	devregarea_t *temp; /* devregarea that we can we use to determine the device number of the interrupt */

 // 	/* initializing local variables */
 // 	temp = (devregarea_t *) INTDEVICEADDR; /* initialization of temp to the address in the bus register associated with the interrupt devices bit map */

 // 	if (lineNum == LINE1 || lineNum == LINE2){
 // 		deviceNum = DEV0;
 // 	}
 // 	if (lineNum == 3){

 // 	}

 // }

 /* Internal helper function that handles Processor Local Timer (PLT) interrupts */
 void pltTimerInt(){
 	if (currentProc != NULL){
 		moveState((state_PTR) BIOSDATAPAGE, &(currentProc->p_s)); /* moving the updated saved exception state from the BIOS Data Page into the Current Process' processor state */
 		currentProc->p_time = currentProc->p_time + (curr_tod - start_tod); /* updating the accumulated processor time used by the Current Process */
 		insertProcQ(&ReadyQueue, currentProc); /* placing the Current Process back on the Ready Queue because it has not completed its CPU Burst */
 		switchProcess(); /* calling the Scheduler to begin execution of the next process on the Ready Queue */
 	}
 	else{
 		PANIC(); /* invoking the PANIC() function to stop the system and print a warning message on terminal 0 */
 	}
 }

 /* Internal helper function that handles interrupts generated by the System-wide Interval Timer */
 void intTimerInt(){
 	LDIT(INITIALINTTIMER); /* placing 100 milliseconds back on the Interval Timer for the next Pseudo-clock tick */

 	/* unblocking all pcbs blocked on the Pseudo-Clock semaphore */
 	// while (i == TRUE){ /* while the flag is true */
 	// 	if (removeBlocked(currentProc->p_semAdd); /* unblocking the first pcb from the process queue of the Current Process' semaphore descriptor */
 	// }
 }

 /* Nucleus' device interrupt handler function (exception code 0) */
 void intTrapH(){
 	/* initializing global variables */
 	STCK(curr_tod); /* initializing the current value on the Time of Day clock */
 	remaining_time = getTIMER(); /* initializing the remaining time left on the Current Process' quantum */

 	/* initializing the line number that the interrupt occurred on */
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE1INT != ALLOFF){ /* if there is an interrupt on line 1 */
 		pltTimerInt();
 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE2INT != ALLOFF){ /* if there is an interrupt on line 2 */
 		intTimerInt();
 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE3INT != ALLOFF){ /* if there is an interrupt on line 3 */

 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE4INT != ALLOFF){ /* if there is an interrupt on line 4 */

 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE5INT != ALLOFF){ /* if there is an interrupt on line 5 */

 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE6INT != ALLOFF){ /* if there is an interrupt on line 6 */

 	}
 	if (((state_PTR) BIOSDATAPAGE)->s_cause & LINE7INT != ALLOFF){ /* if there is an interrupt on line 7 */

 	}
 	// findDeviceNum(); /* calling the function that handles initializing the device number that the interrupt occurred on */

 }